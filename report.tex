\documentclass[10pt,a4paper]{article}
\usepackage[margin=0.75in]{geometry}
\usepackage{amsmath,amssymb}
\usepackage{booktabs}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{multirow}

\hypersetup{colorlinks=true,linkcolor=blue,citecolor=blue,urlcolor=blue}

\usepackage{titlesec}
\titlespacing*{\section}{0pt}{1.2ex plus 0.3ex minus 0.2ex}{0.6ex plus 0.1ex}
\titlespacing*{\subsection}{0pt}{0.8ex plus 0.2ex minus 0.1ex}{0.4ex plus 0.1ex}
\setlength{\parskip}{0.3ex plus 0.1ex minus 0.1ex}
\setlength{\floatsep}{6pt plus 2pt minus 2pt}
\setlength{\textfloatsep}{8pt plus 2pt minus 2pt}
\setlength{\intextsep}{6pt plus 2pt minus 2pt}
\setlength{\abovecaptionskip}{4pt}
\setlength{\belowcaptionskip}{2pt}

\lstset{
  basicstyle=\ttfamily\tiny,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{red},
  breaklines=true,
  frame=single,
  numbers=left,
  numberstyle=\tiny\color{gray},
  xleftmargin=1.5em,
  framexleftmargin=1.5em
}

\title{Analysis of Data Center Network Topologies:\\Path Diversity, Bisection Bandwidth, and the Fat Tree Visualizer}
\author{Au Ze Hong, Maxwell \\ Cloud Computing --- Assignment 1 (Question 5)}
\date{February 2026}

\begin{document}
\maketitle

% ============================================================
\section{Introduction and Literature Survey}
% ============================================================

Modern data centers rely on structured network topologies to deliver high bisection bandwidth and multipath redundancy. The dominant paradigm is the \emph{Clos network}~\cite{clos1953}, which arranges switches in multiple stages so that any input can reach any output through several independent paths. Al-Fares et al.~\cite{alfares2008} showed that a \emph{$k$-ary fat tree}---a folded Clos built from commodity switches---delivers full bisection bandwidth cost-effectively.

Three hyperscalers have published their production designs:
\textbf{Google Jupiter}~\cite{jupiter2015,jupiter2022} uses aggregation blocks interconnected via Optical Circuit Switches (OCS);
\textbf{Amazon}~\cite{aws2022} uses a leaf-spine (2-tier Clos) with full bipartite mesh;
\textbf{Meta}~\cite{meta2014,meta2019} uses a 3-level Clos with spine, fabric, and ToR layers in pods.

We fork the open-source \emph{Fat Tree Visualizer}~\cite{ftreevis} and extend it with three production topology modules, a BFS-based path analysis engine, an exact bisection bandwidth algorithm, and a fault tolerance analyser.

% ============================================================
\section{Solution Methodology}
% ============================================================

\subsection{Path Counting via BFS}
We count shortest paths using BFS: from source $s$, maintain $\mathrm{dist}(v)$ and $\mathrm{count}(v)$ for each node. When neighbour $u$ is first discovered, $\mathrm{count}(u) \leftarrow \mathrm{count}(v)$; when reached again at equal distance, $\mathrm{count}(u) \mathrel{+}= \mathrm{count}(v)$. Complexity: $O(|V|+|E|)$.

For paths through switch $w$, the \emph{product principle} applies: if $\mathrm{dist}(s,w)+\mathrm{dist}(w,t)=\mathrm{dist}(s,t)$, then paths through $w$ $= \mathrm{count}(s \!\to\! w) \times \mathrm{count}(w \!\to\! t)$.

\subsection{Bisection Bandwidth}
For fat trees: $B = k^{d-1} \times k = k^d$ (each of $k^{d-1}$ root switches has $k$ links per side).
For other topologies: we enumerate all balanced host-group partitions via bitmask (feasible for $\leq$20 groups), greedily assign switches to minimise crossing links, and return the minimum.

\subsection{Fault Tolerance Analysis}
We remove the most critical switch (a root/spine switch) and re-run BFS on the reduced graph. We measure: (i)~host pairs that lose all shortest paths, (ii)~average path-count reduction, and (iii)~oversubscription ratio (downlinks/uplinks at the edge layer).

% ============================================================
\section{Answers for the Given Diagram}
% ============================================================

The assignment diagram is a $k{=}2$, $d{=}3$ fat tree with 4 root switches (S1--S4), 4 level-1 switches, 4 edge switches, and 8 hosts (M1--M8, with M1--M6 labelled).

\subsection{Part (a): Server $\to$ Root Switch}
Each server has exactly \textbf{1} shortest path to each individual root switch (length 3), since the fat tree's wiring deterministically maps each upward port to a specific root. There are $k^{d-1} = 4$ root switches, so $4$ total root-reachable paths:
\[
  \text{Paths per root} = \mathbf{1}, \quad \text{Total root switches} = k^{d-1} = 4
\]
\textbf{Verified:} M1 $\to$ S1 = 1 path, M1 $\to$ S2 = 1 path, \ldots, M1 $\to$ S4 = 1 path (each length 3).

\subsection{Part (b): Host-to-Host Paths}

\begin{table}[h]
\centering\small
\caption{Path analysis for the given $k{=}2$, $d{=}3$ fat tree diagram.}
\label{tab:given}
\begin{tabular}{@{}lccp{5.5cm}@{}}
\toprule
\textbf{Pair} & \textbf{Paths} & \textbf{Len.} & \textbf{Explanation} \\
\midrule
M1 $\to$ M3 & 2 & 4 & Different edge switches, same pod. Up through 1 of 2 level-1 switches, down through the destination edge switch: $2$ paths. \\
M1 $\to$ M5 & 4 & 6 & Different pods. Must traverse root: up 3 levels, down 3 levels. At the root level $k{=}2$ choices, giving $2^2{=}4$ paths. \\
M1 $\to$ M5 via S2 & 1 & 6 & S2 is one of 4 root switches. Exactly 1 of the 4 paths passes through S2. By product principle: $\mathrm{count}(M1 \!\to\! S2) \times \mathrm{count}(S2 \!\to\! M5) = 1 \times 1 = 1$. \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Part (c): Bisection Bandwidth}
\[
  B = k^d = 2^3 = \mathbf{8} \text{ link-units}
\]
The minimum cut is at the root level: 4 root switches $\times$ 2 links each crossing the bisection.

% ============================================================
\section{Extension to Other Topologies (Part d)}
% ============================================================

We repeat parts (a)--(c) for three production-inspired topologies and a scaled fat tree ($k{=}4$).

\begin{table}[h]
\centering\small
\caption{Topology parameters for the extended analysis.}
\label{tab:params}
\begin{tabular}{@{}lcccc@{}}
\toprule
& \textbf{Fat Tree ($k{=}4$)} & \textbf{Jupiter} & \textbf{Amazon} & \textbf{Meta} \\
\midrule
Hosts / Switches / Links & 64 / 48 / 192 & 32 / 28 / 96 & 16 / 12 / 48 & 32 / 28 / 96 \\
Root switches    & 16 (level-0)        & 4 (OCS)      & 4 (spine)    & 4 (spine) \\
Oversubscription & 1:1                 & 1:1          & 0.50:1       & 1:1 \\
\bottomrule
\end{tabular}
\end{table}

\subsection{Fat Tree ($k{=}4$, $d{=}3$)}

\textbf{(a)} \textbf{1} path to each root switch (length 3); 16 root switches total.
\textbf{(b)} M1$\to$M3 (same edge switch): \textbf{1} path (len 2). M1$\to$M5 (same pod, different edge): \textbf{4} paths (len 4). M1$\to$M5 through S2: \textbf{0}---S2 is a root switch, but same-pod traffic does not traverse the root level.
\textbf{(c)} Bisection BW $= k^d = 4^3 = \mathbf{64}$ link-units.

\subsection{Google Jupiter}
4 aggregation blocks, 4 OCS, 2 agg + 4 ToR per block, 2 hosts/ToR (32 hosts).

\textbf{(a)} M1$\to$S1 (OCS): \textbf{2} paths (length 3)---M1's ToR connects to 2 agg switches, each connects to the OCS.
\textbf{(b)} M1$\to$M3 (same block, different ToR): \textbf{2} paths (len 4, via 2 agg switches). M1$\to$M5 (same block, same ToR): \textbf{2} paths (len 4). M1$\to$M9 (inter-block): \textbf{16} paths (len 6)---$2 \text{ agg}_\text{src} \times 4 \text{ OCS} \times 2 \text{ agg}_\text{dst} = 16$. Through S2: $\mathbf{4}$ paths.
\textbf{(c)} Bisection BW $= \mathbf{16}$ link-units (exact balanced-partition enumeration; no closed-form---topology is not a regular fat tree).

\subsection{Amazon Leaf-Spine}
4 spine, 8 leaf switches, full bipartite mesh, 2 hosts/leaf (16 hosts).

\textbf{(a)} M1$\to$S1 (spine): \textbf{1} path (length 2)---each host has a single parent leaf.
\textbf{(b)} M1$\to$M3 (different leaf): \textbf{4} paths (len 4, via 4 spines). M1$\to$M2 (same leaf): 1 path (len 2). M1$\to$M5 through S2: \textbf{1} path---each spine carries exactly $1/4$ of traffic.
\textbf{(c)} Bisection BW $= \mathbf{8}$ link-units (exact balanced-partition enumeration).

\subsection{Meta 3-Level Clos}
4 spine, 4 pods (2 fabric + 4 ToR each), 2 hosts/ToR (32 hosts).

\textbf{(a)} M1$\to$S1 (spine): \textbf{2} paths (length 3)---2 fabric switches per pod.
\textbf{(b)} M1$\to$M3 (same pod, different ToR): \textbf{2} paths (len 4, via 2 fabric). M1$\to$M9 (inter-pod): \textbf{16} paths (len 6)---$2 \text{ fabric}_\text{src} \times 4 \text{ spine} \times 2 \text{ fabric}_\text{dst} = 16$. Through S2: $\mathbf{4}$ paths. M1$\to$M5 (same pod) through S2: \textbf{0} paths---intra-pod traffic stays local.
\textbf{(c)} Bisection BW $= \mathbf{16}$ link-units (exact enumeration).

\subsection{Cross-Topology Summary (Parts a--c)}

\begin{table}[h]
\centering\small
\caption{Summary of parts (a)--(c) across all topologies (BFS-computed).}
\label{tab:comparison}
\begin{tabular}{@{}lccccc@{}}
\toprule
\textbf{Metric} & \textbf{Fat Tree} & \textbf{Fat Tree} & \textbf{Jupiter} & \textbf{Amazon} & \textbf{Meta} \\
& \textbf{($k{=}2$)} & \textbf{($k{=}4$)} & & & \\
\midrule
(a) Paths to root      & 4$\times$1   & 16$\times$1  & 4$\times$2  & 4$\times$1  & 4$\times$2 \\
(b) Cross-group paths  & 4   & 4\textsuperscript{$\dagger$}  & 16  & 4  & 16 \\
(b) Paths via 1 root   & 1   & 0\textsuperscript{$\dagger$}   & 4  & 1  & 4 \\
(c) Bisection BW       & 8   & 64  & 16 & 8 & 16 \\
Oversubscription        & 1:1  & 1:1  & 1:1 & 0.50:1 & 1:1 \\
Traffic locality         & No   & No   & Yes & No  & Yes \\
\bottomrule
\end{tabular}
\begin{flushleft}\scriptsize \textsuperscript{$\dagger$}M1$\to$M5 in fat tree $k{=}4$ are in the same pod, so traffic stays within the pod (4 paths, len 4) and does not traverse root switches.\end{flushleft}
\end{table}

% ============================================================
\section{Experiments Beyond the Assignment}
% ============================================================

We go beyond parts (a)--(c) with three experiments that reveal insights not obtainable from lecture material alone. All numbers are generated by our analysis engine (viewable live in the browser).

\subsection{Experiment 1: Multi-Failure Cascade}
We progressively remove 1, 2, \ldots, $N$ root/spine switches and measure path survival (fraction of original shortest-path count that remains) across all host pairs.

\begin{table}[h]
\centering\small
\caption{Path survival (\%) under progressive root-switch failures.}
\label{tab:cascade}
\begin{tabular}{@{}rcccc@{}}
\toprule
\textbf{Roots removed} & \textbf{Fat Tree ($k{=}4$)} & \textbf{Jupiter} & \textbf{Amazon} & \textbf{Meta} \\
& (of 16) & (of 4) & (of 4) & (of 4) \\
\midrule
1 & 94.9 & 79.5 & 76.7 & 79.5 \\
2 & 89.8 & 59.1 & 53.3 & 59.1 \\
3 & 84.7 & 38.6 & 30.0 & 38.6 \\
4 & 79.5 & 18.2 & 6.7 & 18.2 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Insight:} All topologies degrade linearly, but at different rates. The fat tree loses only $\sim$5\% per root removed (16 roots total), retaining 79.5\% at 4 failures---the same point where production topologies collapse. Jupiter and Meta drop to 18.2\% at total root loss; same-pod pairs survive but inter-pod pairs disconnect (54/66). Amazon degrades fastest (to 6.7\%) because its flat 2-tier design has no locality: nearly all cross-leaf pairs disconnect (112/120) when all spines fail.

\subsection{Experiment 2: Network Diameter and Path Diversity}

\begin{table}[h]
\centering\small
\caption{All-pairs shortest-path statistics (computed by BFS over all host pairs).}
\label{tab:stats}
\begin{tabular}{@{}lcccc@{}}
\toprule
& \textbf{Fat Tree ($k{=}4$)} & \textbf{Jupiter} & \textbf{Amazon} & \textbf{Meta} \\
\midrule
Diameter (max distance) & 6 & 6 & 4 & 6 \\
Min host distance       & 2 & 2 & 2 & 2 \\
Avg host distance       & 5.43 & 5.48 & 3.87 & 5.48 \\
Avg paths per pair      & 13.00 & 12.81 & 3.80 & 12.81 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Insight:} Amazon's 2-tier design achieves the lowest diameter (4 vs.\ 6) and average distance (3.87 vs.\ $\sim$5.4), at the cost of 0.50:1 oversubscription. Jupiter and Meta have identical statistics (avgDist = 5.48, avgPaths = 12.81) despite different architectures---their 3-level structure produces equivalent path-length distributions. The fat tree closely matches Jupiter/Meta in path diversity (13.00 vs.\ 12.81) while Amazon has only 3.80 paths/pair, quantifying the redundancy vs.\ simplicity trade-off.

\subsection{Experiment 3: Cost Efficiency}
We define two efficiency metrics: \emph{avg paths per switch} (path diversity per unit of switch hardware) and \emph{bisection BW per link} (bandwidth per unit of cabling).

\begin{table}[h]
\centering\small
\caption{Cost-efficiency metrics.}
\label{tab:cost}
\begin{tabular}{@{}lcccc@{}}
\toprule
& \textbf{Fat Tree ($k{=}4$)} & \textbf{Jupiter} & \textbf{Amazon} & \textbf{Meta} \\
\midrule
Switches          & 48       & 28       & 12       & 28 \\
Links             & 192      & 96       & 48       & 96 \\
Paths/switch      & 0.271    & 0.457    & 0.317    & 0.457 \\
BW/link           & 0.333    & 0.167    & 0.167    & 0.167 \\
\bottomrule
\end{tabular}
\end{table}

\textbf{Insight:} Jupiter and Meta achieve the highest paths-per-switch (0.457), indicating efficient path diversity per unit of switch hardware. The fat tree's BW-per-link (0.333) is $2\times$ that of the production topologies (0.167), but it requires $48$ switches vs.\ $28$---a $71\%$ hardware premium for that bandwidth advantage. Amazon has the fewest switches (12) but the lowest paths-per-switch (0.317) and BW-per-link (0.167), reflecting its lean 2-tier design's limited path diversity.

% ============================================================
\section{Use of AI and Vibe Coding}
% ============================================================

This project used \textbf{Claude Code} (Anthropic's Claude Opus 4.6) as an AI copilot:

\begin{enumerate}[nosep]
  \item \textbf{Correctness audit.} Prompt: ``assess the correctness of the analysis for all supported architectures.'' The AI found three bugs: (i)~hardcoded host count; (ii)~bisection heuristic; (iii)~missing inter-pod analysis.
  \item \textbf{Bug fixing \& feature development.} Targeted fixes plus new analysis modules (multi-failure cascade, all-pairs statistics, cost efficiency).
  \item \textbf{Prompt engineering lesson.} Specific, scoped prompts outperformed vague ones for end-to-end code tracing.
\end{enumerate}

% ============================================================
\section{Discussion and Conclusion}
% ============================================================

\paragraph{Key findings.}
(1)~For the given $k{=}2$, $d{=}3$ diagram: 1 path per root switch (4 roots), 2 M1$\to$M3 paths, 4 M1$\to$M5 paths (1 via S2), bisection BW of 8.
(2)~Multi-failure cascade shows the fat tree retains 79.5\% survival at 4 root failures, while Jupiter/Meta drop to 18.2\% and Amazon to 6.7\%---locality protects intra-pod pairs but inter-group traffic disconnects.
(3)~Amazon's 2-tier design has the lowest diameter (4) and avg distance (3.87) but only 3.80 paths/pair and 0.50:1 oversubscription.
(4)~Jupiter and Meta produce identical graph-theoretic metrics (avgDist=5.48, avgPaths=12.81) despite different architectures---the choice between them is operational (OCS reconfigurability vs.\ pod isolation), not topological.

\paragraph{Limitations.}
All links are treated as equal bandwidth (1 link-unit). In practice, spine links run at higher speeds and Jupiter's OCS dynamically reconfigures bandwidth. Our exact bisection algorithm is exponential in host groups; for $>$20 groups the code falls back to a spatial heuristic.

The source code is in the appendix and runs live in the browser. The original visualizer is at \url{https://github.com/h8liu/ftree-vis}.

% ============================================================
\begin{thebibliography}{9}
\bibitem{ftreevis} H.~Liu, ``Fat Tree Visualizer,'' GitHub. \url{https://github.com/h8liu/ftree-vis}
\bibitem{clos1953} C.~Clos, ``A study of non-blocking switching networks,'' \emph{Bell Syst.\ Tech.\ J.}, 32(2), 1953.
\bibitem{alfares2008} M.~Al-Fares et al., ``A scalable, commodity data center network architecture,'' \emph{ACM SIGCOMM}, 2008.
\bibitem{jupiter2015} A.~Singh et al., ``Jupiter rising,'' \emph{ACM SIGCOMM}, 2015. \url{https://dl.acm.org/doi/10.1145/2785956.2787508}
\bibitem{jupiter2022} S.~Poutievski et al., ``Jupiter evolving,'' \emph{ACM SIGCOMM}, 2022.
\bibitem{aws2022} JR~Rivers, S.~Callaghan, ``Dive deep on AWS networking,'' AWS re:Invent 2022 (NET402).
\bibitem{meta2014} A.~Andreyev, ``Introducing data center fabric,'' Meta Eng.\ Blog, Nov.\ 2014.
\bibitem{meta2019} A.~Andreyev et al., ``Reinventing Facebook's DC network with F16,'' Meta Eng.\ Blog, Mar.\ 2019.
\end{thebibliography}

% ============================================================
\appendix
\section{Key Source Code}
% ============================================================

\subsection{BFS Shortest Path Counting (\texttt{analysis.js})}
\begin{lstlisting}[language=Java]
function countShortestPaths(adj, src, dst) {
  var dist = {}, count = {};
  var queue = [src];
  dist[src] = 0;  count[src] = 1;
  while (queue.length > 0) {
    var node = queue.shift();
    var neighbors = adj[node] || [];
    for (var i = 0; i < neighbors.length; i++) {
      var nb = neighbors[i];
      if (dist[nb] === undefined) {
        dist[nb] = dist[node] + 1;
        count[nb] = count[node];
        queue.push(nb);
      } else if (dist[nb] === dist[node] + 1) {
        count[nb] += count[node];
      }
    }
  }
  return { count: count[dst] || 0, dist: dist[dst] || -1 };
}
\end{lstlisting}

\subsection{Exact Bisection Bandwidth (\texttt{analysis.js})}
\begin{lstlisting}[language=Java]
// Enumerate balanced host-group partitions, assign switches greedily
for (var mask = 1; mask < (1 << nGroups) - 1; mask++) {
  var leftCount = 0;
  for (var g = 0; g < nGroups; g++)
    if (mask & (1 << g)) leftCount += groupSizes[g];
  if (leftCount !== halfHosts) continue;
  // ... assign switches to minimize crossing links ...
  // ... track minimum cut across all partitions ...
}
\end{lstlisting}

\subsection{Fault Tolerance Analysis (\texttt{analysis.js})}
\begin{lstlisting}[language=Java]
function analyzeFaultTolerance(graph, adj) {
  var roots = findRootSwitches(graph);
  var testSwitch = roots[0];
  // Build adjacency without this switch
  var adjReduced = {};
  for (var id in adj) {
    if (id === testSwitch.id) continue;
    adjReduced[id] = adj[id].filter(function(n) {
      return n !== testSwitch.id; });
  }
  // Compare path counts before/after removal
  for (var i = 0; i < hosts.length; i++)
    for (var j = i+1; j < hosts.length; j++) {
      var orig = countShortestPaths(adj, h1, h2);
      var reduced = countShortestPaths(adjReduced, h1, h2);
      // ... measure disconnections and path reduction ...
    }
}
\end{lstlisting}

\end{document}
